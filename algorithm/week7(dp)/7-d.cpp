// 문제
// 자두는 자두를 좋아한다. 그래서 집에 자두나무를 심어두고, 여기서 열리는 자두를 먹고는 한다. 하지만 자두는 키가 작아서 자두를 따먹지는 못하고, 
// 자두가 떨어질 때까지 기다린 다음에 떨어지는 자두를 받아서 먹고는 한다. 자두를 잡을 때에는 자두가 허공에 있을 때 잡아야 하는데, 이는 자두가 말랑말랑하여 바닥에 떨어지면 못 먹을 정도로 뭉개지기 때문이다.

// 매 초마다, 두 개의 나무 중 하나의 나무에서 열매가 떨어지게 된다. 만약 열매가 떨어지는 순간, 자두가 그 나무의 아래에 서 있으면 자두는 그 열매를 받아먹을 수 있다. 
// 두 개의 나무는 그다지 멀리 떨어져 있지 않기 때문에, 자두는 하나의 나무 아래에 서 있다가 다른 나무 아래로 빠르게(1초보다 훨씬 짧은 시간에) 움직일 수 있다. 
// 하지만 자두는 체력이 그다지 좋지 못해서 많이 움직일 수는 없다.

// 자두는 T(1≤T≤1,000)초 동안 떨어지게 된다. 자두는 최대 W(1≤W≤30)번만 움직이고 싶어 한다. 
// 매 초마다 어느 나무에서 자두가 떨어질지에 대한 정보가 주어졌을 때, 자두가 받을 수 있는 자두의 개수를 구해내는 프로그램을 작성하시오. 
// 자두는 1번 자두나무 아래에 위치해 있다고 한다.

// 입력
// 첫째 줄에 두 정수 T, W가 주어진다. 다음 T개의 줄에는 각 순간에 자두가 떨어지는 나무의 번호가 1 또는 2로 주어진다.

// 출력
// 첫째 줄에 자두가 받을 수 있는 자두의 최대 개수를 출력한다.


#include <bits/stdc++.h>
using namespace std;

int t, w, a[1004], dp[1004][2][34];

int go (int idx, int tree, int move) {
    if (move < 0) return -1e9;                  // 움직일 수 있는 횟수를 넘어가는 경우의 가지는 엄청 작은 수 -1e9를 부여해서 max 할때 배제해버림
    if(idx == t) return move == 0 ? 0 : -1e9;   // 최대 move 번만큼 움직였을때의 그 가지는 0을 리턴, 아니면 엄청 작은 수 -1e9를 부여해서 max 할때 배제해버림
    // if (idx == t) return 0;

    int &ret = dp[idx][tree][move];
    if (~ret) return ret;

    ret = max(go(idx+1, tree^1, move-1), go(idx+1, tree, move)) + (tree==a[idx]-1); // 여기 있을때 자두를 얻을 수 있는지, 있다면 1을 더해줌
    return ret;                                                                     // 리프노드에서 그 위로 올라갈때마다 가장 큰 값을 가지고 올라감
}

int main () {
    memset(dp, -1, sizeof(dp));
    cin >> t >> w;

    for (int i=0; i<t; i++) {
        cin >> a[i];
    }

    cout << max(go(0, 1, w-1), go(0, 0, w)) << "\n";    // 가만히 있거나 움직이거나
    return 0;
}


// 가만히 있거나 움직이거나 두가지 경우들이 계속 가지치는 상황
// 마치 이진트리와 같은 형국

// 이를 완탐으로 풀려면 2의 30제곱, 시간 초과
// 따라서 디피로 풀어야함

// dp[idx][tree][move] 이렇게 생각하는 것이 포인트
// tree^1 는 xor 비트연산 이용해서 다른 트리값 넣어줌
// 0^1 이면 1, 1^1이면 0
// 리프노드에서 그 위로 올라갈때마다 가장 큰 값을 가지고 올라감