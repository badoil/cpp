// *
// 문제
// 세준이는 크기가 N*M인 직사각형 도시에 살고 있다. 또, 세준이의 집은 (1, 1)에 있고, 학원은 (N, M)에 있고, 오락실이 C개 있다.

// 세준이의 현재 위치가 (r, c) 일 때, (r+1, c) 또는 (r, c+1)로만 이동할 수 있다. 오락실을 방문할 때는 규칙이 하나 있는데, 
// 오락실 번호가 증가하는 순서대로 가야한다는 것이다. 2번 오락실을 먼저 가고, 그 후에 1번 오락실을 가면 안 되고, 2번 오락실을 가려면, 
// 그 전에 아무 오락실도 가지 않거나, 1번 오락실을 방문했을 때만 가능하다.

// 세준이는 오락실을 K번 방문해서 학원에서 도착하는 경로의 경우의 수가 궁금해지기 시작했다. 오락실을 0개 방문했을 때부터, 
// C개 방문했을 때 까지 경우의 수를 출력하는 프로그램을 작성하시오.

// 입력
// 첫째 줄에 N M C가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, C는 50보다 작거나 같은 자연수 또는 0이다. 
// 둘째 줄부터 C개의 줄에 1번 오락실부터 C번 오락실까지 위치가 차례대로 주어진다. 오락실의 위치가 중복되는 경우는 없지만, 오락실의 위치가 (1,1) 또는 (N,M)일 수도 있다.

// 출력
// 첫째 줄에 0개 방문했을 때, 1개 방문했을 때, ..., C개 방문했을 때 총 경로의 개수를 한 줄에 공백을 사이에 두고 출력한다. 경로의 개수는 1,000,007로 나눈 나머지를 출력한다.


#include <bits/stdc++.h>
using namespace std;

int n, m, c, a[54][54], dp[54][54][54][54];
const int mod = 1000007;

int go(int y, int x, int cnt, int prev) {
    if (y>n || x>m) return 0;               // 맵 벗어났으므로 0 리턴
    if (y==n && x==m) {
        if (a[y][x]==0 && cnt==0) return 1; // 학원(n,m)에 도착했고, 오락실을 다 거쳐옴
        if (a[y][x]>prev && cnt==1) return 1;   // 오락실이 학원과 같은 곳(n,m)에 위치한 경우
        return 0;
    }
    
    int &ret = dp[y][x][cnt][prev];     // dp를 4차원을 생각하는 것이 포인트
    if (ret != -1) return ret;      // 메모제이션
    ret = 0;    // 초기화
    if (a[y][x]==0) {   // 현 위치가 오락실 아닌 경우
        ret = (go(y+1, x, cnt, prev) + go(y, x+1, cnt, prev)) % mod;            // 경로의 개수는 1,000,007로 나눈 나머지를 출력
    } else if (a[y][x]>prev) {  // 현 위치가 오락실인 경우, 그리고 현재 오락실번호가 prev 보다 큰 경우, 즉 오락실 번호가 증가하는 순서대로 간 경우임
        ret = (go(y+1, x, cnt-1, a[y][x]) + go(y, x+1, cnt-1, a[y][x])) % mod;  // 현 위치가 오락실이므로 cnt-1 해주고, 현 위치인 a[y][x]를 prev로 넘김
    }
    return ret;
}

int main () {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> m >> c;
    for (int i=0; i<c; i++) {
        int y, x;
        cin >> y >> x;
        a[y][x] = i;
    }
    
    memset(dp, -1, sizeof(dp));
    for (int i=1; i<=c; i++) {              //  오락실을 K번 방문해서 학원에서 도착하는 경로의 경우의 수
        cout << go(1, 1, i, 0) << " ";
    }
    return 0;
}


// 역시 트리를 생각하라
// 재귀를 돌려서 리프노드에 이르렀을때
// 조건에 맞는, 즉 오락실을 cnt에 맞게 거쳐온 경우에 1을 리턴
// 움직이는 두가지 방법에서 가지를 뻗어나가게 해서, 두 경우를 더 해서 리턴
// 그 값이 cnt 번 방문했을때의 경로 개수

// 전형적인 dp 문제이지만
// 문제에서 이런 dp 풀이를 떠올리고 연관짓는것이 어려움
// 그것을 연습하라

// 중요한것은 모든 경우를 탐색하면서
// 메모제이션을 이용해서 로드를 줄이고
// 조건에 맞지 않는 것은 버리고
// 조건에 맞는 것만 취해서 더해주는 것