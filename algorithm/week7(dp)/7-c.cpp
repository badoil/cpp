// 문제
// 형택이는 1부터 9까지의 숫자와, 구멍이 있는 직사각형 보드에서 재밌는 게임을 한다.

// 일단 보드의 가장 왼쪽 위에 동전을 하나 올려놓는다. 그다음에 다음과 같이 동전을 움직인다.
// 동전이 있는 곳에 쓰여 있는 숫자 X를 본다.
// 위, 아래, 왼쪽, 오른쪽 방향 중에 한가지를 고른다.
// 동전을 위에서 고른 방향으로 X만큼 움직인다. 이때, 중간에 있는 구멍은 무시한다.

// 만약 동전이 구멍에 빠지거나, 보드의 바깥으로 나간다면 게임은 종료된다. 형택이는 이 재밌는 게임을 되도록이면 오래 하고 싶다.
// 보드의 상태가 주어졌을 때, 형택이가 최대 몇 번 동전을 움직일 수 있는지 구하는 프로그램을 작성하시오.

// 입력
// 줄에 보드의 세로 크기 N과 가로 크기 M이 주어진다. 이 값은 모두 50보다 작거나 같은 자연수이다. 
// 둘째 줄부터 N개의 줄에 보드의 상태가 주어진다. 쓰여 있는 숫자는 1부터 9까지의 자연수 또는 H이다. 가장 왼쪽 위칸은 H가 아니다. H는 구멍이다.

// 출력
// 첫째 줄에 문제의 정답을 출력한다. 만약 형택이가 동전을 무한번 움직일 수 있다면 -1을 출력한다.


#include <bits/stdc++.h>
using namespace std;

int n, m, dp[54][54], visited[54][54];
int dy[4] = {-1, 0, 1, 0};
int dx[4] = {0, 1, 0, -1};
char bb[54][54], s[54];

bool in(int a, int b) {
    return 1<=a && a <= n && 1<=b && b<=m;
}

int go(int a, int b) {
    if (!in(a, b) || bb[a][b] == 'H') return 0;
    if (visited[a][b] == 1) {
        cout << -1 << "\n";
        exit(0);
    }

    int &ret = dp[a][b];        // 메모이제이션
    if (ret) return ret;        // 저장된 값 있으면 그것을 리턴
    visited[a][b] = 1;          // 방문 처리
    int value = (int)bb[a][b] - '0';
    for (int i=0; i<4; i++) {
        int ny = a + dy[i]*value;
        int nx = b + dx[i]*value;
        ret = max(ret, go(ny, nx)+1);   // go 함수를 호출하는 것을 동전이 한번 움직이는 것으로 치기 때문에 +1 해줌
    }
    visited[a][b] = 0;         // 어떤 가지에서 방문처리 한것을 다시 되돌리지 않으면 다른 가지에서 영향을 받기에, 다시 돌려놓음
    return ret;
}

int main () {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> m;
    for (int i=1; i<=n; i++) {
        cin >> s;                   // 한줄마다 문자열들 입력
        for(int j=1; j<=m; j++) {
            bb[i][j] = s[j-1];
        }
    }

    cout << go(1, 1) << "\n";
    return 0;
}


// 움직일 수 있는 모든 경우의 수를 구하되 메모이제이션 쓰면서 구함
// 그 증 동전이 가장 많이 움직인 수가 정담
