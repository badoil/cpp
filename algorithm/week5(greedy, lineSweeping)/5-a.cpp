// 문제
// 한 저명한 학자에게 n(0 ≤ n ≤ 10,000)개의 대학에서 강연 요청을 해 왔다. 
// 각 대학에서는 d(1 ≤ d ≤ 10,000)일 안에 와서 강연을 해 주면 p(1 ≤ p ≤ 10,000)만큼의 강연료를 지불하겠다고 알려왔다. 
// 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 
// 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.

// 예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 
// 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.

// 입력
// 첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.

// 출력
// 첫째 줄에 최대로 벌 수 있는 돈을 출력한다.


#include<bits/stdc++.h>
using namespace std;

int n, p, d, ret;
vector<pair<int, int>> v;
priority_queue<int, vector<int>, greater<int>> pq;

int main() {

    cin >> n;

    for (int i=0; i<n; i++) {
        cin >> d >> p;
        v.push_back({d, p});
    }
    sort(v.begin(), v.end());
    for (int i=0; i<n; i++) {
        pq.push(v[i].second);
        if(pq.size() > v[i].first) {    // 만약 4일 안에 해야하는 강연이면 4개의 강연을 할 수 있다는 의미
            pq.pop();
        }
    }

    while(pq.size()) {
        ret += pq.top();
        pq.pop();
    }

    cout << ret << "\n";
    return 0;
}


// greedy 는 우선순위큐 사용할 생각 하라
// 이 문제는 벡터와 우선순위큐 자료형이 핵심
// 우선 일수를 기준으로 오름차순으로 벡터에 pair 를 집어넣고
// 우선순위큐에는 벡터 순서대로(일수기준으로) 강연료만 오름차순으로 넣는다
// 우선순위큐가 일수를 넘어가면 가장 작은 수를 팝해럼(오름차순이기 때문에 top 값이 가장 작은수)
// 즉 최소값을 삭제하는 방식으로 최대값을 만드는것

// 큐에는 날짜 순으로 페이가 들어가 있음
// 즉 해당 i의 날짜가 큐 사이즈 보다 크다면
// 그 날짜 안에 해당 강연을 할 수 있다는 의미가 됨
// 반대로 큐사이즈가 더 크면 큐를 팝해서 최소 페이를 삭제