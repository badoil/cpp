// *
// 문제
// 남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 
// 그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다. 
// 김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 
// 김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.
// 남극언어의 모든 단어는 "anta"로 시작되고, "tica"로 끝난다. 남극언어에 단어는 N개 밖에 없다고 가정한다. 
// 학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.

// 입력
// 첫째 줄에 단어의 개수 N과 K가 주어진다. N은 50보다 작거나 같은 자연수이고, K는 26보다 작거나 같은 자연수 또는 0이다. 
// 둘째 줄부터 N개의 줄에 남극 언어의 단어가 주어진다. 
// 단어는 영어 소문자로만 이루어져 있고, 길이가 8보다 크거나 같고, 15보다 작거나 같다. 모든 단어는 중복되지 않는다.

// 출력
// 첫째 줄에 김지민이 K개의 글자를 가르칠 때, 학생들이 읽을 수 있는 단어 개수의 최댓값을 출력한다.

#include<bits/stdc++.h>
using namespace std;


int n, k, words[54];
string s;

int count(int mask) {
    int cnt=0;
    for (int word: words) {
        if (word && ((word & mask) == word)) cnt++;        // 만든 mask 가 word 와 같다면 k로 그 단어를 만든것
    }
    return cnt;
}


int go(int idx, int k, int mask) {
    if (k<0) return 0;
    if (idx == 26) return count(mask);
    int ret = go(idx+1, k-1, mask | (1<<idx));      // 
    if (idx == 'a'-'a' || idx == 'n' - 'a' || idx == 't' - 'a' || idx == 'i' - 'a' || idx == 'c' - 'a') {       // 안타티카에 해당하는 알파벳이거나 아니거나, 두가지 경우의 수 뿐
        ret = max(ret, go(idx+1, k, mask));     // 안타티카에 해당하는 문자는 안다고 가정, 그래서 k, mask 값 그대로
    }

    return ret;
}


int main() {
    cin >> n >> k;

    for (int i=0; i<n; i++) {
        cin >> s;
        for (char c: s) {
            words[i] |= (1<<(c - 'a'));         // 해당 c에 해당하는 정수에 비트마스킹, 이렇게 하면 해당 단어의 모든 말파벳문자에 해당하는 비트마스킹 하는 셈
        }
    }

    cout << go(0, k, 0) << "\n";

    return 0;
}


// 주어진 n개의 단어 각각을 k개의 문자로 만들 수 있는가를 체크하는것
// idx 로 알파벳 하나씩 체크하고, k를 하나씩 감소시켜서(k개의 알파벳만 가르칠 수 있으므로) 체크
// 안타티카에 해당하는 알파벳이거나 아니거나, 두가지 경우의 수 뿐 
// 재귀함수로 완전탐색후 최대값 구하기