// 문제
// KOI 본선 대회에 N명의 학생이 참가했다. 이 학생들을 각각 1부터 N까지 정수로 표현하자. 
// 대회가 끝나고 성적을 발표하는데, 이 대회는 전체 학생의 등수를 발표 하는 대신, 
// 두 학생 A, B가 대회 본부에 찾아가면 본부는 두 학생 중 어느 학생이 더 잘 했는지를 알려준다. 둘 이상의 학생이 동점인 경우는 없다(동점인 경우는 없다).

// 자신의 전체에서 등수가 궁금한 학생들은 둘 씩 짝을 지어서 대회 본부에 총 M번 질문을 했다. 
// 여러분은 등수를 알고 싶은 학생 X와 대회 본부의 질문에 대한 답들 로부터 이 학생 X의 등수 범위를 찾아서 출력한다. 
// 질문에 대한 답으로 알 수 있는 최대한 정확한 답을 출력한다.

// 입력
// 표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에 세 정수 N, M, X가 공백을 사이에 두고 주어진다. (2 ≤ N ≤ 100000, 1 ≤ M ≤ min(N(N-1)/2, 100000), 1 ≤ X ≤ N) . 
//다음 M 줄에는 각각 두 정수 A, B가 주어지는데, 이 뜻은 학생 A가 학생 B보다 더 잘했다는 뜻이다. 같은 A, B가 둘 이상의 줄에 주어지는 경우는 없고, 입력된 값이 정확함이 보장된다.

// 출력
// 표준 출력으로 두 정수 U, V (1 ≤ U ≤ V ≤ N)를 출력한다. 
// 이는 학생 X의 가능한 가장 높은 등수가 U, 가능한 가장 낮은 등수가 V임을 나타낸다. 
// 만약 학생 X의 가능한 등수가 정확하게 하나라면, U = V이다.

#include <bits/stdc++.h>
using namespace std;

int n, m, x, a, b, visited[100005];
vector<int> f[100005], c[100005];

int bfs(int x, vector<int> adj[]) {
    int ret=0;
    visited[x] = 1;
    queue<int> q;
    q.push(x);
    while(q.size()) {
        int here = q.top();
        q.pop();
        for (int there: adj[here]) {
            if (visited[there] == 1) continue;
            visited[there] = 1;
            q.push(there);
            ret++;
        }
    }
    return ret;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n >> m >> x;
    for (int i=0; i<m; i++) {
        cin >> a >> b;
        f[a].push_back(b);          // 내 뒤에 몇명있나 구하는 용, 방향이 앞->뒤 이므로
        c[b].push_back(a);          // 내 앞에 몇명있나 구하는 용, 방향이 뒤->앞 이므로
    }

    int best = bfs(x, c);               // 내 앞에 몇명있나
    fill(visited, visited+100005, 0);
    int worst = bfs(x, f);              // 내 뒤에 몇명있나

    cout << best + 1 << n-worst << "\n";
    return 0;
}


// 학생들 성적순을 노드들과 간선으로 생각
// 어떤 노드를 기준(여기서는 x)으로 자신보다 앞에 있는 노드 갯수와
// 자신보다 뒤에 있는 노드 갯수를 구하는것

// 즉 단방향으로 된 그래프로 생각하는것
// 이때 가중치는 동일하고 일직선으로 주욱 나열되어 있는 그래프를 생각할것
// a - b - c - d 이런식
// 만약 c 기준으로 생각하면
// c애서 a 로 갈때 거치는 노드수가 자기 앞에 있는 학생들
// 이를 이용해서 가능한 최고 등수 구하는것
// 가능한 최악의 등수는 그 반대로 하는것

// 이를 위해서 앞->뒤 방향 벡터와
// 뒤->앞 방향 벡터 두개 필요
// 이들 벡터값 이용해서 bfs (dfs이어도 무방)