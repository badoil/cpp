// 문제
// N 명의 학생들이 앞뒤로 일렬로 서 있다. 각 학생은 1부터 N까지 서로 다른 번호가 적힌 카드들 중 하나를 가지고 있다. 
// 학생들에게서 자신보다 뒤에 서있으면서 더 작은 번호의 카드를 가진 학생들의 명단을 하나도 빠짐없이 모두 받았다. 이 명단을 통해 학생들이 가지고 있는 카드의 번호를 알아내려고 한다.

// 예를 들어, 일렬로 서 있는 5명의 학생들을 앞에서부터 순서대로 “학생1, 학생2, 학생3, 학생4, 학생5”라고 하고, 
// 학생들에게 받은 명단을 통해 다음과 같이 5개의 순서쌍이 만들어졌다고 하자. 순서쌍 (X,Y)는 학생Y 가 학생X 보다 뒤에 있으면서 더 작은 번호를 가지고 있다는 것을 의미한다.

// (1,2), (1,5), (3,4), (3,5), (4,5)
// 이 자료를 분석하면 학생1, 학생2, 학생3, 학생4, 학생5는 각각 3, 1, 5, 4, 2가 적힌 카드를 가지고 있음을 알 수 있다.

// 다른 예로 5명 학생들에게 받은 명단으로 다음과 같은 6개의 순서쌍이 만들어 졌다고 하자.
// (1,2), (1,3), (1,5), (2,5), (3,4), (3,5)
// 이 경우, 학생들이 잘못된 명단을 제시한 것이다. 순서쌍 (2,5)에 의하면 학생2는 학생5보다 큰 번호의 카드를 가지고 있다. 
// 그런데 만일 학생4의 카드가 학생5의 카드보다 작은 번호라면 순서쌍 (2,4)가 존재해야 하고, 
// 반대로 학생4의 카드가 학생5의 카드보다 큰 번호라면 순서쌍 (4,5)가 존재해야 한다. 
// 그런데 둘 다 존재하지 않기 때문에 학생들이 잘못된 명단을 제시한 것이다.

// 학생들로부터 받은 명단으로 만들어진 순서쌍을 입력으로 받아, 학생들이 가지고 있는 카드 번호를 알아내는 프로그램을 작성하라.

// 입력
// 표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학생 수 N (1 ≤ N ≤ 100,000)과 순서쌍의 수 M (0 ≤ M ≤ 1,000,000)이 공백으로 분리되어 주어진다. 
// 일렬로 서 있는 학생들을 순서대로 학생1, 학생2, ... , 학생N 이라고 하자. 다음 M개의 각 줄에는 두 개의 자연수 X와 Y가 공백으로 분리되어 주어진다. 
// 이것은 학생Y가 학생X 보다 더 작은 번호가 적힌 카드를 가지고 있다는 것을 의미하는 순서쌍이다 (1 ≤ X < Y ≤ N). 입력에 중복된 순서쌍은 없다.

// 출력
// 표준 출력으로, 주어진 순서쌍을 통해 학생들이 가지고 있는 카드 번호를 알 수 있으면 학생들이 서 있는 순서대로 카드번호를 공백으로 분리하여 출력한다. 그렇지 않으면 -1을 출력한다


include <bits/stdc++.h>
using namespace std;

int n, m, x, y, v[100004], visited[100004];
bool flag;

int main () {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> n >> m;
    for (int i=0; i<m; i++) {
        cin >> x >> y;          // x번 학생이 y번 학생보다 큰 카드번호를 가지고 있고 줄 앞에 서 있음
        v[x]++; v[y]++;         // x번 학생의 카드번호가 더 크므로 +1 해주고 y번 학생에는 -1 해줌
    }

    for (int i=1; i<=n; i++) {
        v[i] += i;              // 모든 학생이 순서대로 카드번호를 가지고 있다고 가정
        visited[v[i]]++;        // v[i] 즉 i번째 학생의 카드번호를 체크
    }

    for (int i=1; i<=n; i++) {
        if (visited[i] == 0 || visited[i] > 2) flag = 1;        // 그 카드가 체크 안되거나 2 이상이면 답 없음
    }

    if (flag) {
        cout << -1 << "\n";
        return 0;
    } else {
        for (int i=1; i<=n; i++) {
            cout << v[i] << " ";
        }
    }
    return 0;
}


// 이 문제는 어떤 알고리즘 적용하는 문제가 아니라
// ad hoc 문제, 창의적으로 가정하면서 풀어야하는 문제
// 이 문제의 핵심은
// 학생들에게서 자신보다 뒤에 서있으면서 더 작은 번호의 카드를 가진 학생들의 명단을 하나도 빠짐없이 모두 받았다
// 사실이다. 그 사실로 카드번호를 유추 할 수 있다.
// 학생들이 자기 순서와 같은 카드를 가지고 있다고 가정하고
// 나오는 명단인 (X, Y) 통해 X번 학생의 카드를 1 올리고 Y번 학생의 카드를 1 내려주면서 확인함

// https://junseok.tistory.com/239  이 블로그 설명 잘되어있음
// 예제 입력 1을 통해서 값을 확인하겠습니다.
// 2, 5번 학생이 1번 학생보다 뒤에 있지만 카드의 수가 작습니다.
// ->
// 1번 학생은 3을 가지고 있는 것을 알 수 있습니다.
// 그 이유는 첫번째로 서있는 학생이 4이상을 가지고 있다면 뒤에서 1,2,3..이 나올 것이기에 명단을 2개만 가질 수 없습니다.
// 위의 코드에 대입해보면 1번 학생은 3이 됨

// 4,5번 학생이 3번 학생보다 뒤에 있지만 카드의 수가 작습니다.
// ->
// 1번 학생이 3을 가지고 있어 3번 학생은 4 or 5를 가져야합니다. 만약 3번 학생이 4를 가지게 된다면 5번을 가질 수 있는 학생은 2번이 유일합니다.
// 하지만 2번 학생이 5를 가지게 된다면 (2, 3)의 명단도 있어야하지만 없는 것을 보아 3번 학생은 무조건 5를 가져야합니다.
// 5번 학생이 4번 학생보다 뒤에 있지만 카드의 수가 작습니다.
// ->
// 4번 학생이 가질 수 있는 카드의 경우는 4번, 2번, 1번입니다. 만약 4번 학생이 2번을 가지게 되면 2번 학생이 4번을 가져야 합니다.
// 하지만 2번 학생이 4를 가지게 된다면 (2, 4), (2, 5)의 명단이 있어야하지만 없는 것을 보아 4번 학생은 4를 가져야합니다.
// 같은 논리로 2번 학생이 1번, 5번 학생이 2번을 가져야 합니다.
